var documenterSearchIndex = {"docs":
[{"location":"guides/calibration/#Calibration","page":"Calibration","title":"Calibration","text":"JCGECalibrate converts SAM and IO data into calibrated parameters and starting values. The calibration process is model-agnostic but assumes a canonical input schema. The goal is a consistent benchmark where accounting identities and zero-profit conditions hold.","category":"section"},{"location":"guides/calibration/#Inputs","page":"Calibration","title":"Inputs","text":"sam.csv: square SAM matrix with labeled rows/columns\nsets.csv: canonical lists of goods, activities, factors, and institutions\nOptional: subsets.csv, labels.csv, mappings.csv, params.csv\n\nThe Imports guide describes the canonical schema and how to build these files from raw sources.","category":"section"},{"location":"guides/calibration/#Outputs","page":"Calibration","title":"Outputs","text":"Calibration produces:\n\nParameter tables for production, demand, and tax structures.\nStarting values for levels and prices.\nConsistent mappings that align data with model sets.","category":"section"},{"location":"guides/calibration/#Typical-workflow","page":"Calibration","title":"Typical workflow","text":"using JCGECalibrate\nsam = load_sam_table(\"path/to/sam.csv\"; goods=..., factors=...)\nstart = compute_starting_values(sam)\nparams = compute_calibration_params(sam, start)\n\nCalibration is deterministic and should produce a consistent benchmark that satisfies model accounting identities.","category":"section"},{"location":"guides/calibration/#Validating-calibration","page":"Calibration","title":"Validating calibration","text":"Before building the model, check that:\n\nAll accounts balance.\nMappings cover all required sets.\nCalibration outputs match the expected model inputs.\n\nIf a balance check fails, fix the SAM or mappings before proceeding.","category":"section"},{"location":"guides/calibration/#Common-pitfalls","page":"Calibration","title":"Common pitfalls","text":"Misaligned labels between sam.csv and sets.csv.\nMissing or duplicated accounts in the SAM.\nImplicit zeros that should be explicit.","category":"section"},{"location":"guides/calibration/#Next-steps","page":"Calibration","title":"Next steps","text":"Modeling guide to connect parameters to blocks.\nImports guide for schema details and data ingestion.","category":"section"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This quick start shows the minimal steps to install the core JCGE packages and run a reference model. For full workflows and modeling guidance, see the Guides.","category":"section"},{"location":"getting-started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"Julia 1.9+ installed and on your PATH.\nA clean project environment (recommended).","category":"section"},{"location":"getting-started/#Install","page":"Getting Started","title":"Install","text":"Create or activate a project before adding packages:\n\nimport Pkg\nPkg.activate(\".\")\n\nThen add the core packages:\n\nimport Pkg\nPkg.add([\n    \"JCGECore\",\n    \"JCGEBlocks\",\n    \"JCGERuntime\",\n    \"JCGECalibrate\",\n    \"JCGEOutput\",\n])","category":"section"},{"location":"getting-started/#Run-a-reference-model","page":"Getting Started","title":"Run a reference model","text":"using JCGEExamples\nresult = JCGEExamples.StandardCGE.solve()","category":"section"},{"location":"getting-started/#Inspect-results","page":"Getting Started","title":"Inspect results","text":"The returned result contains the solved model and output artifacts. Typical next steps include inspecting reports and exporting tables via JCGEOutput.","category":"section"},{"location":"getting-started/#Solver-note","page":"Getting Started","title":"Solver note","text":"For MCP models, PATHSolver is required. See the Imports guide for license setup.","category":"section"},{"location":"getting-started/#Next-steps","page":"Getting Started","title":"Next steps","text":"Read the Modeling guide to understand blocks and model structure.\nFollow the Calibration and Output guides for data workflows and reporting.","category":"section"},{"location":"guides/blocks/#Blocks","page":"Blocks","title":"Blocks","text":"Blocks are reusable building blocks that emit equation ASTs and model variables. A model is assembled by selecting and configuring blocks, then organizing them into sections (production, households, markets, etc.). Each block has a clear responsibility and declares which sets and parameters it requires.","category":"section"},{"location":"guides/blocks/#Forms","page":"Blocks","title":"Forms","text":"Many blocks accept a form parameter to choose the functional form (for example Cobb-Douglas or CES). Use a global form for all items or provide a per-entity mapping where supported.\n\nTypical forms include:\n\nCobb-Douglas for smooth substitution.\nCES for flexible elasticities.\nLeontief for fixed proportions.","category":"section"},{"location":"guides/blocks/#Typical-block-categories","page":"Blocks","title":"Typical block categories","text":"Most models mix a small set of block categories:\n\nProduction blocks that map inputs to outputs.\nMarket clearing blocks for goods and factors.\nIncome and demand blocks for institutions.\nClosure and numeraire blocks.\n\nOrganize blocks into sections so the model structure is readable and easy to diagnose.","category":"section"},{"location":"guides/blocks/#Parameterization","page":"Blocks","title":"Parameterization","text":"Blocks take parameters from calibrated data. Keep parameter names consistent across blocks so calibration outputs can be reused. Prefer explicit mappings over implicit defaults when building large models.","category":"section"},{"location":"guides/blocks/#Extending-blocks","page":"Blocks","title":"Extending blocks","text":"Custom blocks can be created by following the same interface as the built-ins: declare required sets, map parameters, and emit equation ASTs. This makes new components fully compatible with the runtime and output tooling.","category":"section"},{"location":"guides/blocks/#Guidelines","page":"Blocks","title":"Guidelines","text":"Blocks should be reusable and model-agnostic.\nAvoid hard-coded sector/factor counts; always work with sets.\nAll equations are registered with block and tag metadata to enable rendering and reporting.\n\nSee the JCGEBlocks documentation at https://Blocks.JCGE.org for the full block catalog and parameters.","category":"section"},{"location":"packages/#Packages","page":"Packages","title":"Packages","text":"This project is organized as a set of focused Julia packages. The table below summarizes responsibilities and typical usage.\n\nPackage Purpose Typical Use\nJCGECore RunSpec, sections, sets/mappings, scenarios, validation Define model structure and constraints\nJCGEBlocks Reusable CGE blocks Assemble production/household/market systems\nJCGERuntime Compilation and solver execution Solve a RunSpec with Ipopt/PATH\nJCGECalibrate SAM loading and calibration Derive parameters and starting values\nJCGEOutput Rendering and results containers Export equations, tidy results, DualSignals\nJCGEExamples Reference models Canonical model ports and tests\nJCGEImportData Canonical IO/SAM schema Convert external data to CSV inputs\nJCGEImportMPSGE MPSGE.jl importer Translate MPSGE objects to RunSpecs\nJCGEAgentInterface MCP-compatible interface for agents Tooling for AI integrations\n\nEach package has its own documentation site and API reference. This repository keeps the ecosystem narrative consistent, but package-specific details belong in those package docs.","category":"section"},{"location":"packages/#Resources","page":"Packages","title":"Resources","text":"Package Source Code Documentation\nJCGECore https://github.com/equicirco/JCGECore.jl https://Core.JCGE.org\nJCGEBlocks https://github.com/equicirco/JCGEBlocks.jl https://Blocks.JCGE.org\nJCGERuntime https://github.com/equicirco/JCGERuntime.jl https://Runtime.JCGE.org\nJCGECalibrate https://github.com/equicirco/JCGECalibrate.jl https://Calibrate.JCGE.org\nJCGEOutput https://github.com/equicirco/JCGEOutput.jl https://Output.JCGE.org\nJCGEExamples https://github.com/equicirco/JCGEExamples.jl https://Examples.JCGE.org\nJCGEImportData https://github.com/equicirco/JCGEImportData.jl https://ImportData.JCGE.org\nJCGEImportMPSGE https://github.com/equicirco/JCGEImportMPSGE.jl https://ImportMPSGE.JCGE.org\nJCGEAgentInterface https://github.com/equicirco/JCGEAgentInterface.jl https://AgentInterface.JCGE.org","category":"section"},{"location":"contact/#Contact-and-Citation","page":"Contact & Citation","title":"Contact & Citation","text":"","category":"section"},{"location":"contact/#Authorship","page":"Contact & Citation","title":"Authorship","text":"JCGE was designed by Riccardo Boero.   Email: ribo@nilu.no","category":"section"},{"location":"contact/#How-to-cite","page":"Contact & Citation","title":"How to cite","text":"JCGE is the umbrella framework; please cite it in any work that uses the ecosystem. Each package is also versioned and archived on Zenodo with its own DOI, which provides a stable reference point for the exact code used.\n\nTo make models easy to document and replicate, you may wish to record the package versions used in your model's Project.toml and, where relevant, reference the corresponding repository DOIs. This is optional guidance intended to give you flexible ways to keep executions fully traceable.\n\nIf you use JCGE in your CGE models, please cite it as:\n\nBoero, R. JCGE - Julia Computable General Equilibrium Framework [software], 2026\nDOI: 10.5281/zenodo.18282436\nURL: https://JCGE.org\n\nBibTeX:\n\n@software{boero_jcge_2026,\n  title        = {JCGE - Julia Computable General Equilibrium Framework},\n  author       = {Boero, Riccardo},\n  year         = {2026},\n  doi          = {10.5281/zenodo.18282436},\n  url          = {https://JCGE.org}\n}","category":"section"},{"location":"project/#Project","page":"Project","title":"Project","text":"JCGE is a multi-package Julia ecosystem for computable general equilibrium (CGE) modeling. It favors small, focused packages with clear responsibilities over a single monolith. This repo provides the cross-cutting narrative: how the ecosystem fits together, how to model with it, and where to find the right package for a task.","category":"section"},{"location":"project/#Goals","page":"Project","title":"Goals","text":"Make CGE model structure explicit and composable.\nSeparate calibration, modeling, runtime, and reporting concerns.\nProvide reusable building blocks that scale from simple to large models.\nKeep the ecosystem approachable for applied economists and data teams.","category":"section"},{"location":"project/#Scope-of-this-documentation-website","page":"Project","title":"Scope of this documentation website","text":"Framework architecture and workflows (see the Guides)\nCross-package guides and examples (start with Getting Started)\nHigh-level package responsibilities (see Packages)","category":"section"},{"location":"project/#Ecosystem-map","page":"Project","title":"Ecosystem map","text":"The JCGE ecosystem is built as a set of focused packages that connect through shared data structures and explicit interfaces:\n\nCore abstractions and schemas live in JCGECore.\nReusable modeling blocks are defined in JCGEBlocks.\nModel execution and solver orchestration run through JCGERuntime.\nCalibration workflows live in JCGECalibrate.\nReporting and export live in JCGEOutput.\nReference models and end-to-end examples live in JCGEExamples.\nData ingestion is handled by JCGEImportData and JCGEImportMPSGE.","category":"section"},{"location":"project/#Design-principles","page":"Project","title":"Design principles","text":"Modularity over monoliths.\nExplicit data schemas and traceable transformations.\nSeparation between model structure, calibration, runtime, and reporting.\nReproducible workflows that scale from small to large models.\nClear boundaries between packages with stable interfaces.","category":"section"},{"location":"project/#Workflow-overview","page":"Project","title":"Workflow overview","text":"Define model structure and blocks (Modeling).\nCalibrate parameters and data to the canonical schema (Calibration).\nRun models through the runtime and solver integration (Running).\nGenerate outputs, reports, and exports (Output).\n\nSee the Guides section for detailed steps across each stage.","category":"section"},{"location":"project/#How-this-approach-differs","page":"Project","title":"How this approach differs","text":"Many CGE systems are delivered as closed or tightly coupled toolchains. JCGE takes a different path: open, composable, and inspectable building blocks that can be reused across models and institutions.\n\nOpen source and fully inspectable from data ingest to solver interface.\nReusable blocks that can be recomposed instead of copied between models.\nFree and open access documentation with modern tooling.\nScientific rigor through explicit data schemas and reproducible workflows.\nPerformance-oriented Julia implementation for fast iteration.\nAccessible workflows, including integration with AI-assisted tooling.","category":"section"},{"location":"project/#Who-this-is-for","page":"Project","title":"Who this is for","text":"Applied economists and policy modeling teams.\nResearch groups that need transparent, inspectable models.\nOrganizations that want reusable components instead of single-use scripts.\nStudents and educators building modern CGE workflows.","category":"section"},{"location":"project/#Status-and-roadmap","page":"Project","title":"Status and roadmap","text":"JCGE is fully working and fully developed to support professional and research CGE work. As an open source project it will continue to improve and expand. The next focus is deeper data integration in the JCGEImportData package.","category":"section"},{"location":"guides/modeling/#Modeling","page":"Modeling","title":"Modeling","text":"This guide outlines a typical modeling workflow in JCGE, from data-backed calibration to a solved model and exported outputs. It focuses on the structural steps and how the pieces fit together.\n\nIf you are new to the ecosystem, start with Getting Started and then return here for a deeper walkthrough of model construction.","category":"section"},{"location":"guides/modeling/#1.-Start-from-data","page":"Modeling","title":"1. Start from data","text":"Use JCGECalibrate to load a SAM and produce calibrated parameters and starting values. The canonical input format is described in the Calibration and Imports guides.\n\nKey ideas:\n\nData should be mapped into the canonical schema before building blocks.\nCalibration outputs become model parameters and initial values.\nKeep data transformations explicit so the pipeline is reproducible.","category":"section"},{"location":"guides/modeling/#2.-Build-a-RunSpec","page":"Modeling","title":"2. Build a RunSpec","text":"A RunSpec is the structural description of a model: sets, mappings, sections, blocks, and closures. It is a readable definition of the economic structure separate from any specific calibration dataset.\n\nusing JCGECore\nusing JCGEBlocks\n\nsets = Sets(goods, activities, factors, institutions)\nmappings = Mappings(Dict(a => a for a in activities))\n\nprod = production(:prod, activities, factors, goods; form=:cd, params=prod_params)\nmarket = composite_market_clearing(:market, goods, activities)\nnumeraire = numeraire(:numeraire, :factor, :LAB, 1.0)\n\nsections = [\n    section(:production, [prod]),\n    section(:markets, [market]),\n    section(:closure, [numeraire]),\n]\n\nspec = build_spec(\"MyModel\", sets, mappings, sections)","category":"section"},{"location":"guides/modeling/#Common-block-types","page":"Modeling","title":"Common block types","text":"JCGEBlocks provides a library of reusable economic blocks. Typical models mix:\n\nProduction blocks (Cobb-Douglas, CES, Leontief).\nMarket clearing blocks.\nDemand or institutional behavior blocks.\nClosure and numeraire blocks.\n\nThe Blocks guide gives concrete examples and parameterization details.","category":"section"},{"location":"guides/modeling/#Closures-and-normalization","page":"Modeling","title":"Closures and normalization","text":"Closures specify which variables are fixed and which adjust. A numeraire normalizes the price level and avoids indeterminacy.","category":"section"},{"location":"guides/modeling/#3.-Validate","page":"Modeling","title":"3. Validate","text":"using JCGERuntime\nreport = validate_model(spec)\nreport.ok || error(\"Model validation failed\")\n\nValidation checks block consistency, coverage of sets, and structural integrity before solving. It is a good place to catch missing mappings or parameters.","category":"section"},{"location":"guides/modeling/#4.-Solve","page":"Modeling","title":"4. Solve","text":"using JCGERuntime, Ipopt\nresult = run!(spec; optimizer=Ipopt.Optimizer)\n\nSolver configuration depends on the model class. For MCP models, PATHSolver is required. Use the Running guide for configuration patterns and runtime options.","category":"section"},{"location":"guides/modeling/#5.-Inspect-and-export","page":"Modeling","title":"5. Inspect and export","text":"Use JCGEOutput to render equations or export results.\n\nTypical outputs include:\n\nEquation listings for verification.\nReport tables by sector or account.\nScenario comparison exports.","category":"section"},{"location":"guides/modeling/#Tips-for-building-models","page":"Modeling","title":"Tips for building models","text":"Start from a minimal model and expand iteratively.\nKeep data and structure separate so you can swap datasets.\nPrefer reusable blocks over copy-pasted equations.\nMake closures explicit and document them in the model description.","category":"section"},{"location":"guides/modeling/#Next-steps","page":"Modeling","title":"Next steps","text":"Blocks guide for reusable components and parameterization.\nCalibration guide for data workflows and schema details.\nRunning guide for solvers, scenarios, and batch execution.","category":"section"},{"location":"guides/output/#Output-and-Reporting","page":"Output & Reporting","title":"Output & Reporting","text":"JCGEOutput provides backend-agnostic rendering and results containers. It is designed to support reporting across solvers and to keep outputs consistent across scenarios.","category":"section"},{"location":"guides/output/#Equation-rendering","page":"Output & Reporting","title":"Equation rendering","text":"using JCGEOutput\ntext = render_equations(result; format=:markdown)\n\nRendered equations are derived from the equation AST, not solver objects.\n\nUse this to:\n\nAudit model structure.\nCompare variants of the same model.\nGenerate human-readable documentation.","category":"section"},{"location":"guides/output/#Results-containers","page":"Output & Reporting","title":"Results containers","text":"Results are stored in a canonical Results object with primals/duals and metadata. Export helpers include JSON, CSV, Arrow/Parquet, and a tidy long-table form for analysis.\n\nTypical workflows include:\n\nExporting sector-level tables for reports.\nWriting tidy outputs for dashboards or notebooks.\nArchiving scenario runs for reproducibility.","category":"section"},{"location":"guides/output/#SAM-style-reporting","page":"Output & Reporting","title":"SAM-style reporting","text":"sam_from_solution can map model flows back to a SAM-like table. This is optional and may be incomplete if the model does not track all flows.","category":"section"},{"location":"guides/output/#Scenario-comparison","page":"Output & Reporting","title":"Scenario comparison","text":"When running multiple scenarios, keep outputs in consistent formats so differences can be computed directly. A common pattern is to export a tidy table for each run and merge on keys.","category":"section"},{"location":"guides/output/#Next-steps","page":"Output & Reporting","title":"Next steps","text":"Running guide for scenario workflows.\nModeling guide for block-level inspection.","category":"section"},{"location":"#Julia-Computable-General-Equilibrium-Framework","page":"Home","title":"Julia Computable General Equilibrium Framework","text":"<table style=\"border-collapse: collapse; text-align: left; margin: 0;\">\n  <tr>\n    <td style=\"padding: 0 1rem 0 0; vertical-align: top; text-align: left;\">\n      <picture>\n        <source srcset=\"assets/jcge_logo_dark.png\" media=\"(prefers-color-scheme: dark)\">\n        <img src=\"assets/jcge_logo_light.png\" alt=\"JCGE\" style=\"max-width: 130px; height: auto;\">\n      </picture>\n    </td>\n    <td style=\"vertical-align: top; text-align: left;\">\nJCGE is a modular, block-based framework for Computable General Equilibrium (CGE)\nmodeling in Julia. This documentation is the project entry point: it describes\narchitecture, workflows, and package boundaries while the package APIs live in their\nown docs.\n    </td>\n  </tr>\n</table>","category":"section"},{"location":"#Start-here","page":"Home","title":"Start here","text":"This site is organized around a project overview, a quick start, and a set of cross-package guides. Use the links below to jump to the part of the framework you need.\n\nIf you are looking for package-level APIs, start with the Packages page.\n\nProject overview: design goals and how the ecosystem fits together\nGetting Started: install packages and run your first model\nPackages: what each package does in the ecosystem\nGuides: modeling, calibration, output, and imports\nContact & citation: how to cite and who to reach","category":"section"},{"location":"#Ecosystem-at-a-glance","page":"Home","title":"Ecosystem at a glance","text":"JCGE is a family of focused Julia packages. The Packages page gives a quick map of the ecosystem and where to look for detailed API references.","category":"section"},{"location":"guides/imports/#Imports","page":"Imports","title":"Imports","text":"JCGE provides two import paths: data ingestion and MPSGE model conversion. The goal is to make external data and legacy model structures reusable within the JCGE ecosystem.","category":"section"},{"location":"guides/imports/#Data-import-(IO/SAM)","page":"Imports","title":"Data import (IO/SAM)","text":"JCGEImportData defines a canonical CSV schema and helpers to build a SAM from IO tables. It is designed for adapters that extract data from external sources like Eurostat or GTAP.\n\nKey outputs:\n\nsam.csv\nsets.csv\noptional labels, subsets, mappings, and parameters","category":"section"},{"location":"guides/imports/#Recommended-workflow","page":"Imports","title":"Recommended workflow","text":"Extract raw IO/SAM data from a source dataset.\nMap accounts into the canonical schema.\nGenerate sets.csv and sam.csv.\nValidate that labels and mappings align.\n\nUse the Calibration guide once the canonical files are in place.","category":"section"},{"location":"guides/imports/#MPSGE-import","page":"Imports","title":"MPSGE import","text":"JCGEImportMPSGE converts an MPSGE.jl model object to a JCGE RunSpec. This is a converter and conformance bridge, not a competing authoring format.\n\nTypical flow:\n\nusing MPSGE, JCGEImportMPSGE\nm = MPSGEModel()\n# build MPSGE model...\nrun_spec = import_mpsge(m)\n\nWhen the source model is complementarity-based, the importer emits MCP blocks so the model can be solved with PATHSolver.","category":"section"},{"location":"guides/imports/#Choosing-an-import-path","page":"Imports","title":"Choosing an import path","text":"Use JCGEImportData when you are starting from data and building new models.\nUse JCGEImportMPSGE when you need to translate an existing MPSGE model.","category":"section"},{"location":"guides/imports/#Next-steps","page":"Imports","title":"Next steps","text":"Calibration guide for canonical schema usage.\nModeling guide for building RunSpecs from blocks.","category":"section"},{"location":"guides/running/#Running-Models","page":"Running Models","title":"Running Models","text":"This guide covers how to run models, configure solvers, and work with scenarios. For structural modeling steps, see the Modeling guide.\n\nThe JCGEExamples package provides reference models ported from the literature. Each model exposes a model, baseline, and solve entry point.\n\nusing JCGEExamples\n\nresult = JCGEExamples.StandardCGE.solve()","category":"section"},{"location":"guides/running/#Build-a-spec-and-run-it","page":"Running Models","title":"Build a spec and run it","text":"You can also run a custom RunSpec directly once it is validated:\n\nusing JCGERuntime, Ipopt\n\nreport = validate_model(spec)\nreport.ok || error(\"Model validation failed\")\n\nresult = run!(spec; optimizer=Ipopt.Optimizer)","category":"section"},{"location":"guides/running/#Solvers","page":"Running Models","title":"Solvers","text":"NLP models: Ipopt (Ipopt.Optimizer)\nMCP models: PATHSolver (PATHSolver.Optimizer)\n\nPATHSolver requires a license for larger problems. You can provide the license via environment variable:\n\nexport PATH_LICENSE_STRING=\"<LICENSE STRING>\"\n\nIf the problem is small enough, PATHSolver can run without a license.","category":"section"},{"location":"guides/running/#Runtime-options","page":"Running Models","title":"Runtime options","text":"Typical runtime controls include:\n\nChoice of optimizer and solver parameters.\nOutput directories and report formats.\nScenario labels for comparison workflows.\n\nExact options depend on the runtime package entry points you use.","category":"section"},{"location":"guides/running/#Scenarios-and-experiments","page":"Running Models","title":"Scenarios and experiments","text":"Run the same model under multiple parameter sets to compare outcomes. A common workflow is to:\n\nDefine a baseline calibration.\nApply policy or shock parameters.\nSolve and compare outputs.\n\nUse consistent naming for scenarios to make reports reproducible.","category":"section"},{"location":"guides/running/#Troubleshooting","page":"Running Models","title":"Troubleshooting","text":"Check validation reports before solving.\nConfirm that all calibration outputs map to block parameters.\nFor PATHSolver issues, confirm the license string and solver availability.","category":"section"},{"location":"guides/running/#Next-steps","page":"Running Models","title":"Next steps","text":"Blocks guide for reusable components.\nCalibration guide for data workflows and schema details.\nOutput guide for reporting and exports.","category":"section"}]
}
